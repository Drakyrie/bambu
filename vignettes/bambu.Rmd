---
title: "Analysing Long Read RNA-Seq data with bambu"
author: Ying Chen, Yuk Kei Wan, Jonathan GÃ¶ke
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bambu}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning=FALSE, message=FALSE,
  comment = "##>"
)
```


# Introduction
*[Bambu](https://github.com/GoekeLab/bambu)* is a method  for transcript discovery and quantification from long read RNA-Seq data. Bambu uses aligned reads and genome reference annotations as input, and will return abundance estimates for all known transcripts and for newly discovered transcripts. Bambu uses the information from the reference annotations to correct misalignment at splice junctions, then reduces the aligned reads to read equivalent classes, and uses this information to identify novel transcripts across all samples of interest. Reads are then assigned to transcripts, and expression estimates are obtained using an expectation maximisation algorithm. Here, we present an example workflow for analysing Nanopore long read RNA-Sequencing data from two human cancer cell lines from the Singapore Nanopore Expression Project (SG-NEx).


# Content
* [Quick Start: Transcript discovery and quantification with bambu](#quick-start)
* [A complete workflow to identify and quantify transcript expression from Nanopore RNA-Seq data](#complete-workflow)
  + [Input data](#input-data)
    - [Aligned reads (bam files)](#bam-files)
    - [Genome sequence (fasta file/ BSGenome object)](#genome-sequences)
    - [Genome annotations (bambu annotations object/ gtf file / TxDb object)](#annotations)
  + [Transcript discovery and quantification](#transcript-discovery-quantification)
    - [Run bambu](#run-bambu)
    - [Visualise results](#visualise-results)
    - [Obtain gene expression estimates from transcript expression](#gene-expression)
    - [Save data (gtf/text)](#save-data)
  + [Identify differentially expressed genes](#DESeq2)
  + [Identify differential transcript usage](#DEXSeq)
* [Running bambu with large number of samples](#large-sample-num)
* [Getting Help](#get-help)
* [Citing bambu](#cite-bambu)
* [Session Information](#session-info)


# Quick start: Transcript discovery and quantification with bambu {#quick-start}

## Installation
You can install bambu from github:
```{r, eval = FALSE}
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
devtools::install_github("GoekeLab/bambu")
```

## General Usage
The default mode to run *bambu* is using a set of aligned reads (bam files), reference genome annotations (gtf file, TxDb object, or bambuAnnotation object), and reference genome sequence (fasta file or BSgenome). bambu will return a summarizedExperiment object with the genomic coordinates for annotated and new transcripts and transcript expression estimates:
```{r, eval = FALSE}
library(bambu)
 
test.bam <- system.file("extdata", "SGNex_A549_directRNA_replicate5_run1_chr9_1_1000000.bam", package = "bambu")
 
se <- bambu(reads = test.bam, annotations = "TxDb.Hsapiens.UCSC.hg38.knownGene", genomeSequence = "BSgenome.Hsapiens.NCBI.GRCh38")
```

We highly recommend to use the same annotations that were used for genome alignment. If you have a gtf file and fasta file you can run bambu with the following options:
```{r, eval = FALSE}
test.bam <- system.file("extdata", "SGNex_A549_directRNA_replicate5_run1_chr9_1_1000000.bam", package = "bambu")
  
fa.file <- system.file("extdata", "Homo_sapiens.GRCh38.dna_sm.primary_assembly_chr9_1_1000000.fa", package = "bambu")
 
gtf.file <- system.file("extdata", "Homo_sapiens.GRCh38.91_chr9_1_1000000.gtf", package = "bambu")
 
bambuAnnotations <- prepareAnnotationsFromGTF(gtf.file)
 
se <- bambu(reads = test.bam, annotations = bambuAnnotations, genomeSequence = fa.file)
```
# A complete workflow to identify and quantify transcript expression from Nanopore RNA-Seq data {#complete-workflow}
To demonstrate the usage of Bambu, we used long-read RNA-Seq data generated using Oxford Nanopore Sequencing from the NanoporeRNASeq package, which consists of 6 samples from two human cell lines (K562 and MCF7). Each of these cell lines has three replicates, with 1 direct RNA sequencing data and 2 cDNA sequencing data. Reads are aligned to chromosome 22 (Grch38) and stored as bam files. 

## Input data {#input-data}
### Aligned reads (bam files) {#bam-files}
```{r}
devtools::install_github("GoekeLab/NanoporeRNASeq")
library(NanoporeRNASeq)
devtools::load_all()
library(bambu)
```
```{r}
data("sample_info")
sample_info
```
```{r}
data("bamFiles")
```

### Genome sequence (fasta file/ BSGenome object) {#genome-sequences}
```{r}
# get path to fasta file
fasta_path <- system.file("extdata", "Homo_sapiens.GRCh38.dna_sm.primary_assembly_chr22_1_25409234.fa", package="NanoporeRNASeq")
# BSgenome
library(BSgenome.Hsapiens.NCBI.GRCh38)
```

### Genome annotations (bambu annotations object/ gtf file / TxDb object) {#annotations}
```{r}
data("annotation")
```

## Transcript discovery and quantification {#transcript-discovery-quantification}
### Running bambu {#run-bambu}
#### Apply *bambu* to perform EM on  extended annotations 
```{r}
se <- bambu(reads = bamFiles, annotations = annotation, genomeSequence = "BSgenome.Hsapiens.NCBI.GRCh38", extendAnnotations = TRUE)
se
```
*bambu* allows quantification without isoform discovery
```{r}
seUnextended <- bambu(reads = bamFiles, annotations = annotation, genomeSequence = "BSgenome.Hsapiens.NCBI.GRCh38")
seUnextended
```

### Visualise results {#visualise-results}
We can check the estimated transcript expression using heatmap:
```{r, fig.width = 8, fig.height = 6}
colData(se)$groupVar <- sample_info$cellLine
colnames(se) <- sample_info$sample_id
colData(se)$name <- sample_info$sample_id
plot.bambu(se, group.variable = "groupVar", type = "heatmap")
```

or with PCA plot
```{r, fig.width = 8, fig.height = 6}
colData(se)$groupVar <-  sample_info$cellLine
plot.bambu(se, group.variable = "groupVar", type = "pca")
```

Check for gene examples 
Single gene examples can also be checked using plot functions from *bambu*
```{r, fig.width = 8, fig.height = 10}
plot.bambu(se, type = "annotation", gene_id = unique(rowData(se)$GENEID)[10])

```

### Obtain gene expression estimates from transcript expression {#gene-expression}
Gene expression can be obtained from transcript expression using this function:
```{r}
seGene <- transcriptToGeneExpression(se)
seGene
```

Gene expression heatmap
```{r, fig.width = 8, fig.height = 6}
colData(seGene)$groupVar <-  sample_info$cellLine
plot.bambu(seGene, group.variable = "groupVar", type = "heatmap")
```

Gene expression PCA plot
```{r, fig.width = 8, fig.height = 6}
colData(seGene)$groupVar <-  sample_info$cellLine
plot.bambu(seGene, group.variable = "groupVar", type = "pca")
```

### Save data (gtf/text){#save-data}
```{r}
writeBambuOutput(se, path = "./bambu/")
```

## Identifying differentially expressed genes {#DESeq2}
We used *DESeq2* to find the differentially expressed genes:
```{r}
library(DESeq2)
dds <- DESeqDataSetFromMatrix(apply(assays(seGene)$counts,c(1,2),round),#tmp_wide[,-1],
                                   colData = colData(se),
                                   design = ~ groupVar)
system.time(dds.deseq <- DESeq(dds))

deGeneRes <- DESeq2::results(dds.deseq, independentFiltering=FALSE)
```

```{r}
head(deGeneRes[order(deGeneRes$padj),])
```

```{r}
summary(deGeneRes)
```
```{r, fig.width = 8, fig.height = 6}
plotMA(deGeneRes, ylim = c(-3,3))
```

Plotting shrinked lFC results
```{r, fig.width = 8, fig.height = 6}
library(apeglm)
resLFC <- lfcShrink(dds.deseq, coef="groupVar_MCF7_vs_K562", type="apeglm")
plotMA(resLFC, ylim = c(-3,3))
```

## Identifying differential expression for isoform detection {#DEXSeq}
We used *DEXSeq* to detect alternative used isoforms.
```{r}
library(DRIMSeq)
count.data <- as.data.frame(rowData(se))
count.data$gene_id <- count.data$GENEID
count.data$feature_id <- count.data$TXNAME
count.data$GENEID <- count.data$TXNAME <- NULL

count.data <- cbind(count.data, assays(se)$counts)

sample.info <- as.data.frame(colData(se))
sample.info$sample_id <- sample.info$name
sample.info$name <- NULL
d <- dmDSdata(counts=count.data, samples=sample.info)

n_samp_gene <- 1
n_samp_feature <- 1
min_count_gene <- 1
min_count_feature <- 1
dFilter <- dmFilter(d,
              min_samps_feature_expr = n_samp_feature, 
              min_samps_feature_prop = n_samp_feature,
              min_samps_gene_expr = n_samp_gene, 
              min_feature_expr = min_count_feature,
              min_gene_expr = min_count_gene,
              min_feature_prop=0.1)
table(table(counts(dFilter)$gene_id)) ## number of isoforms 



```

```{r}
library(DEXSeq)
formulaFullModel <- as.formula("~sample + exon + groupVar:exon")


dxd <- DEXSeqDataSet(countData=round(as.matrix(counts(dFilter)[,-c(1:2)])),
                     sampleData=DRIMSeq::samples(dFilter),
                     design=formulaFullModel,
                     featureID = counts(dFilter)$feature_id,
                     groupID=counts(dFilter)$gene_id)


system.time({
  dxd <- estimateSizeFactors(dxd)
  print('Size factor estimated')
  dxd <- estimateDispersions(dxd, formula = formulaFullModel)
  print('Dispersion estimated')
  #dxd <- estimateExonFoldChanges( dxd )
  dxd <- testForDEU(dxd, fullModel = formulaFullModel)
  print('DEU tested')
  dxd <- estimateExonFoldChanges(dxd, fitExpToVar="groupVar")
  print('Exon fold changes estimated')
}) 
```

```{r}
dxr <- DEXSeqResults(dxd, independentFiltering=FALSE)
head(dxr)
```


```{r}
library(stageR)
strp <- function(x) substr(x,1,15)
qval <- perGeneQValue(dxr)
dxr.g <- data.frame(gene=names(qval),qval)

columns <- c("featureID","groupID","pvalue")
dxr_pval <- as.data.frame(dxr[,columns])
head(dxr_pval)

pConfirmation <- matrix(dxr_pval$pvalue,ncol=1)
dimnames(pConfirmation) <- list(strp(dxr_pval$featureID),"transcript")
pScreen <- qval
names(pScreen) <- strp(names(pScreen))
tx2gene <- as.data.frame(dxr_pval[,c("featureID", "groupID")])
for (i in 1:2) tx2gene[,i] <- strp(tx2gene[,i])


stageRObj <- stageRTx(pScreen=pScreen, pConfirmation=pConfirmation,
                      pScreenAdjusted=TRUE, tx2gene=tx2gene)
stageRObj <- stageWiseAdjustment(stageRObj, method="dtu", alpha=0.5)
suppressWarnings({
  dex.padj <- getAdjustedPValues(stageRObj, order=FALSE,
                                 onlySignificantGenes=TRUE)
})
```

```{r}
dxrDT <- data.table(as.data.frame(dxr))
setnames(dxrDT, old = c('groupID','featureID'), new = c('geneID','txID'))
dex.padj <- data.table(dex.padj)

dxrDT <- dex.padj[dxrDT, on = c('geneID','txID')]
head(dxrDT)
```


```{r, fig.width = 8, fig.height = 6}
dxrDT[,sigLFC2:=(padj < 0.5&(abs(log2fold_MCF7_K562)>=2))]
ggplot(dxrDT, aes(y = log2fold_MCF7_K562, x = exonBaseMean, color = as.factor(padj<0.5)))+
  geom_point(size = 0.5)+
     scale_x_log10()+
  scale_color_manual(values = c('grey','indianred'), name = "Significant")+
     xlab("Mean of normalized counts")+
    ylab("Log2 Fold change")+
  theme_minimal()

```

```{r}
dxrDT[padj<0.5,.(geneID, txID, log2fold_MCF7_K562,K562,MCF7)]
```
# Running bambu with large number of samples {#large-sample-num}
For larger sample numbers we recommend to write the processed data to a file:
```{r, eval = FALSE}
bambu(reads = test.bam, readClass.outputDir = "./bambu/", annotations = bambuAnnotations, genomeSequence = fa.file)
```
# Getting Help {#get-help}
## Advanced Options
More stringent filtering thresholds imposed on potential novel transcripts
* Keep novel transcripts with min 5 read count in at least 1 sample:
```{r, eval = FALSE}
bambu(reads, annotations, genomeSequence, isoreParameters = list(min.readCount = 5))
```
* Keep novel transcripts with min 5 samples having at least 2 counts:
```{r, eval = FALSE}
bambu(reads, annotations, genomeSequence, isoreParameters = list(min.sampleNumber = 5))
```
* Filter out transcripts with relative abundance within gene lower than 10%:
```{r, eval = FALSE}
bambu(reads, annotations, genomeSequence, isoreParameters = list(min.readFractionByGene = 0.1))
```
Quantification without bias correction
The default estimation automatically does bias correction for expression estimates. However, you can choose to perform the quantification without bias correction.
```{r, eval = FALSE}
bambu(reads, annotations, genomeSequence, emParameters = list(bias = FALSE))
```
Parallel computation
bambu allows parallel computation.
```{r, eval = FALSE}
bambu(reads, annotations, genomeSequence, ncore = 8)
```
See *[manual](https://github.com/GoekeLab/bambu/blob/master/docs/bambu_0.1.0.pdf)* for details to customize other conditions.


# Citing bambu {#cite-bambu}
A manuscript describing bambu is currently in preparation. If you use bambu for your research, please cite using the following doi: 10.5281/zenodo.3900025.

# Session Information {#session-info}
```{r}
sessionInfo()
```



